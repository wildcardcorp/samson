from samson.macs.poly1305 import Poly1305
from samson.block_ciphers.rijndael import Rijndael
from samson.utilities.bytes import Bytes
import unittest

testvec = [
    { "k" : b"\xec\x07\x4c\x83\x55\x80\x74\x17\x01\x42\x5b\x62\x32\x35\xad\xd6",
      "m" : b"\xf3\xf6",
      "r" : b"\x85\x1f\xc4\x0c\x34\x67\xac\x0b\xe0\x5c\xc2\x04\x04\xf3\xf7\x00",
      "n" : b"\xfb\x44\x73\x50\xc4\xe8\x68\xc5\x2a\xc3\x27\x5c\xf9\xd4\x32\x7e",
      "x" : b"\xf4\xc6\x33\xc3\x04\x4f\xc1\x45\xf8\x4f\x33\x5c\xb8\x19\x53\xde"
    },
    { "k" : b"\x75\xde\xaa\x25\xc0\x9f\x20\x8e\x1d\xc4\xce\x6b\x5c\xad\x3f\xbf",
      "m" : b"",
      "r" : b"\xa0\xf3\x08\x00\x00\xf4\x64\x00\xd0\xc7\xe9\x07\x6c\x83\x44\x03",
      "n" : b"\x61\xee\x09\x21\x8d\x29\xb0\xaa\xed\x7e\x15\x4a\x2c\x55\x09\xcc",
      "x" : b"\xdd\x3f\xab\x22\x51\xf1\x1a\xc7\x59\xf0\x88\x71\x29\xcc\x2e\xe7"
    },
    { "k" : b"\x6a\xcb\x5f\x61\xa7\x17\x6d\xd3\x20\xc5\xc1\xeb\x2e\xdc\xdc\x74",
      "m" : b"\x66\x3c\xea\x19\x0f\xfb\x83\xd8\x95\x93\xf3\xf4\x76\xb6\xbc\x24\xd7\xe6\x79\x10\x7e\xa2\x6a\xdb\x8c\xaf\x66\x52\xd0\x65\x61\x36",
      "r" : b"\x48\x44\x3d\x0b\xb0\xd2\x11\x09\xc8\x9a\x10\x0b\x5c\xe2\xc2\x08",
      "n" : b"\xae\x21\x2a\x55\x39\x97\x29\x59\x5d\xea\x45\x8b\xc6\x21\xff\x0e",
      "x" : b"\x0e\xe1\xc1\x6b\xb7\x3f\x0f\x4f\xd1\x98\x81\x75\x3c\x01\xcd\xbe"
    },
    { "k" : b"\xe1\xa5\x66\x8a\x4d\x5b\x66\xa5\xf6\x8c\xc5\x42\x4e\xd5\x98\x2d",
      "m" : b"\xab\x08\x12\x72\x4a\x7f\x1e\x34\x27\x42\xcb\xed\x37\x4d\x94\xd1\x36\xc6\xb8\x79\x5d\x45\xb3\x81\x98\x30\xf2\xc0\x44\x91\xfa\xf0\x99\x0c\x62\xe4\x8b\x80\x18\xb2\xc3\xe4\xa0\xfa\x31\x34\xcb\x67\xfa\x83\xe1\x58\xc9\x94\xd9\x61\xc4\xcb\x21\x09\x5c\x1b\xf9",
      "r" : b"\x12\x97\x6a\x08\xc4\x42\x6d\x0c\xe8\xa8\x24\x07\xc4\xf4\x82\x07",
      "n" : b"\x9a\xe8\x31\xe7\x43\x97\x8d\x3a\x23\x52\x7c\x71\x28\x14\x9e\x3a",
      "x" : b"\x51\x54\xad\x0d\x2c\xb2\x6e\x01\x27\x4f\xc5\x11\x48\x49\x1f\x1b"
    }]


class Poly1305TestCase(unittest.TestCase):
    def test_allvecs(self):
        for vec in testvec:
            nonce = Rijndael(vec['k']).encrypt(vec['n']).change_byteorder()
            poly  = Poly1305(vec['r'], clamp_r=False)
            self.assertEqual(poly.generate(vec['m'], nonce), vec['x'])


    #https://tools.ietf.org/html/rfc7539#section-2.5.2
    def test_rfc7539(self):
        #key = 0x85d6be7857556d337f4452fe42d506a80103808afb0db2fd4abff6af4149f51b
        s   = Bytes(0x0103808afb0db2fd4abff6af4149f51b).change_byteorder()
        r   = 0x85d6be7857556d337f4452fe42d506a8
        msg = b'Cryptographic Forum Research Group'

        p1305 = Poly1305(r)
        self.assertEqual(p1305.generate(msg, s), b"\xa8\x06\x1d\xc10Q6\xc6\xc2+\x8b\xaf\x0c\x01'\xa9")


    def test_nonce_reuse(self):
        s    = Bytes(0x0103808afb0db2fd4abff6af4149f51b).change_byteorder()
        r    = 0x85d6be7857556d337f4452fe42d506a8
        msg1 = b'Cryptographic Forum Research Group'

        p1305 = Poly1305(r)

        sig1 = p1305.generate(msg1, s)

        for _ in range(5):
          msg2 = Bytes.random(len(msg1))
          sig2 = p1305.generate(msg2, s)

          candidates = Poly1305.nonce_reuse_attack(msg1, sig1, msg2, sig2)

          self.assertTrue((p1305.r, s.int()) in candidates)
